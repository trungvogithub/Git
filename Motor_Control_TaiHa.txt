
#include "main.h"
#include "math.h"
#define pi 3.141592
#define T 0.01
#define lamda 0.99
TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;

struct package {
	uint8_t header[4];
	float pc_kp;
	float pc_ki;
	float pc_kd;
	float pc_voltage;
	float pc_speed;
	float pc_angle;
}; //28 bytes uart dma transmit

struct receive {
	uint8_t header[4];
	uint8_t command[4];
	float set_speed;
	float set_angle;
	float lock_kp;
	float lock_ki;
	float lock_kd;
}; //28 bytes uart dma receive

UART_HandleTypeDef huart3;
DMA_HandleTypeDef hdma_usart3_rx;
DMA_HandleTypeDef hdma_usart3_tx;

void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_USART3_UART_Init(void);
void multiply_matrix(double x[4][4], uint8_t h, uint8_t c,  double y[4][4], uint8_t p, uint8_t q,  double z[4][4]);
void add_matrix(double x[4][4], double y[4][4], uint8_t h, uint8_t c, double z[4][4]);
void sub_matrix(double x[4][4], double y[4][4], uint8_t h, uint8_t c, double z[4][4]);
void multiply_matrix_number(double x[4][4], uint8_t h, uint8_t c, double y, double z[4][4]);
void divide_matrix_number(double x[4][4], uint8_t h, uint8_t c, double y, double z[4][4]);
void tranpose_matrix(double x[4][4], uint8_t h, uint8_t c,  double y[4][4]);
void estimation_str(void);
void estimation_pid(void);
void update_pc(void);
void speed_control(void);
void position_control(void);
void MRC(void);
void get_speed_and_control(void);
void initial(void);
uint16_t count, last_count = 0, set_angle = 0;
double speed, speed_k1, speed_k2, set_speed = 8.23, set_speed_k1, angle;
double voltage, voltage_k1, voltage_k2;
double theta_old[4][1];
double theta[4][4] = { {-0.22}, {1.78}, {1}, {0} };
double P[4][4] = { {1000, 0, 0, 0}, {0, 1000, 0, 0}, {0, 0, 1000, 0}, {0, 0, 0, 1000} };
double phi[4][4], phit[4][4], temp[4][4], temp1[4][4], num[4][4], den[4][4];
double coeff;
double s0, s1, t0, t1, r1;
double L[4][4];
double err, check_voltage;
double error, error_k1, error_k2;
double kp, ki, kd;
uint8_t check_count = 0;
uint8_t mode = 's', command = 's', str_enable = 'e';
struct package pc_package;
struct receive package_receive;

int main(void)
{

  HAL_Init();

  SystemClock_Config();

  MX_GPIO_Init();
  MX_DMA_Init();
  MX_TIM1_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_USART3_UART_Init();
	HAL_TIM_Base_Start_IT(&htim3);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
	HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_1 | TIM_CHANNEL_2);
  HAL_UART_Receive_DMA(&huart3, (uint8_t*)&package_receive, 28);
  HAL_UART_Transmit_DMA(&huart3, (uint8_t*)&pc_package, 28);
 
  while (1)
  {

  }
  /* USER CODE END 3 */
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  
  UNUSED(huart);
	if (package_receive.header[0] == 'd' && package_receive.header[1] == 'v' && package_receive.header[2] == 'r' && package_receive.header[3] == 'c') {
		command = package_receive.command[0];
	  if (package_receive.command[1] == 'f') {
			HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_SET);
		  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);
		}else if(package_receive.command[1] == 'b') {
			HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_RESET);
		  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
		}
		mode = package_receive.command[2];
		str_enable = package_receive.command[3];
		set_speed = package_receive.set_speed;
		set_angle = package_receive.set_angle;
	}
  
}
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  USART3->CR3 &= ~(1<<7);
}
void initial(void) {
	theta[0][0] = -0.22; theta[1][0] = 1.78; theta[2][0] = 1; theta[3][0] = 0;
	TIM2->CNT = 0;
	speed = 0; speed_k1 = 0; speed_k2 = 0;
	count = 0; last_count = 0;
	err = 0; error = 0; error_k1 = 0; error_k2 = 0;
	voltage = 0; voltage_k1 = 0; voltage_k2 = 0;
	for (uint8_t x = 0; x <= 3; x++) {
		for(uint8_t y = 0; y <= 3; y++) {
		   if (x == y) P[x][y] = 1000;
		   else P[x][y] = 0;
		}
	}
}
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(htim);
  if(htim->Instance == htim3.Instance && command == 'r') {
    /*estimation_str();
	  MRC();
	  get_speed_and_control();*/
		
	  //phi = [ -speed_k1 ] 
	  //      [ voltage_k1]
		if(mode == 's') {
      estimation_pid();
	    speed_control();
		}else if(mode == 'p') {
			position_control();
		}
	  
		update_pc();	
	
  }else if(command == 's') {
		htim1.Instance->CCR1 = 0;
		initial();
	}
}
void update_pc(void) {
	if(check_count == 20) {
		check_count = 0;
	  pc_package.header[0] = 'p'; pc_package.header[1] = 'c'; pc_package.header[2] = 'd'; pc_package.header[3] = 'p';
	  pc_package.pc_kp = (float)kp; pc_package.pc_ki = (float)ki; pc_package.pc_kd = (float)kd;
	  pc_package.pc_speed = (float)speed; pc_package.pc_angle = (float)angle; pc_package.pc_voltage = (float)voltage;
	  USART3->CR3 |= (1<<7);
	}
	check_count++;
}
void speed_control(void) {

  if(str_enable == 'd') {
    kp = package_receive.lock_kp;
		ki = package_receive.lock_ki;
		kd = package_receive.lock_kd;		
	}else if(str_enable == 'e') {
		kp = fabs((theta[0][0] + 0.8332031)/theta[1][0]);
	  ki = fabs(1.015665/theta[1][0]);
	  kd = fabs(0.0008521437/theta[1][0]);
	}
	
	if(kp < 0.001) kp = 0.28;
	
	count = __HAL_TIM_GET_COUNTER(&htim2);
	if((uint16_t)(count - last_count) > 30000) {
		speed = (65536 - (uint16_t)(count - last_count)) / T;
		speed = (speed / 1496) * 2*pi;
	}else{
	  speed = (uint16_t)(count - last_count) / T;
		speed = (speed / 1496) * 2*pi;
	}
	last_count = count;
	//kp = 0.54; ki = 0.69;kd=0.00058;
  error = set_speed - speed;
	voltage =  voltage_k1 + kp*(error - error_k1) + ki*T*(error + error_k1)/2 + kd*(error - 2*error_k1 + error_k2)/T;
	if(voltage > 12) voltage = 12;
	else if (voltage < 0) voltage = 0;
  htim1.Instance->CCR1 = (int)((voltage/12)*1023);
}
void position_control(void) {
	if(str_enable == 'd') {
    kp = package_receive.lock_kp;
		ki = package_receive.lock_ki;
		kd = package_receive.lock_kd;		
	}
	
}
void estimation_pid(void) {
	phi[0][0] = -speed_k1;
	phi[1][0] = voltage_k1;

	tranpose_matrix(phi, 2, 1, phit);
	multiply_matrix(phit, 1, 2, theta, 2, 1, temp);
	err = speed - temp[0][0];
	
	multiply_matrix(P, 2, 2, phi, 2, 1, num);
	multiply_matrix(phit, 1, 2, P, 2, 2, temp);
	multiply_matrix(temp, 1, 2, phi, 2, 1, den);
	den[0][0] += lamda;
	divide_matrix_number(num, 2, 1, den[0][0], L);
	
	multiply_matrix(L, 2, 1, temp, 1, 2, temp1);
	sub_matrix(P, temp1, 2, 2, temp);
	divide_matrix_number(temp, 2, 2, lamda, P);
	
	multiply_matrix_number(L, 2, 1, err, temp);
	add_matrix(theta, temp, 2, 1, theta);
	
	theta_old[0][0] = theta[0][0];
	theta_old[1][0] = theta[1][0];
	
	speed_k1 = speed;
	voltage_k1 = voltage;
	set_speed_k1 = set_speed;
	error_k2 = error_k1;
	error_k1 = error;
}
void estimation_str(void) 
{
  phi[0][0] = -speed_k1;
	phi[1][0] = -speed_k2;
	phi[2][0] = voltage_k1;
	phi[3][0] = voltage_k2;
	
	tranpose_matrix(phi, 4, 1, phit);
	multiply_matrix(phit, 1, 4, theta, 4, 1, temp);
	err = speed - temp[0][0];
	
	multiply_matrix(P, 4, 4, phi, 4, 1, num);
	multiply_matrix(phit, 1, 4, P, 4, 4, temp);
	multiply_matrix(temp, 1, 4, phi, 4, 1, den);
	den[0][0] += lamda;
	divide_matrix_number(num, 4, 1, den[0][0], L);
	
	multiply_matrix(L, 4, 1, temp, 1, 4, temp1);
	sub_matrix(P, temp1, 4, 4, temp);
	divide_matrix_number(temp, 4, 4, lamda, P);
	double prevent = theta[2][0];
	multiply_matrix_number(L, 4, 1, err, temp);
	add_matrix(theta, temp, 4, 1, theta);
	
	speed_k2 = speed_k1;
	speed_k1 = speed;
	voltage_k2 = voltage_k1;
	voltage_k1 = voltage;
	set_speed_k1 = set_speed;
	//if(theta[2][0] < 0.01 & theta[2][0] > -0.01) theta[2][0] = 0.4897;
	
}
void MRC(void) 
{
	
	r1 = theta[3][0] / theta[2][0];
	t0 = 1.002 / theta[2][0];
	t1 = 0.001662 / theta[2][0];
	s0 = (0.0005457 - theta[0][0]) / theta[2][0];
	s1 = (1.82e-6 - theta[1][0]) / theta[2][0];
	
}
void get_speed_and_control(void) 
{
	
	count = __HAL_TIM_GET_COUNTER(&htim2);
	if(count - last_count > 30000) {
		speed = (65536 - (count - last_count)) / T;
		speed = (speed / 1496) * 2*pi;
	}else{
	  speed = (count - last_count) / T;
		speed = (fabs(speed) / 1496) * 2*pi;
	}
	last_count = count;
	
	voltage = -(r1*voltage_k1) + (t0*set_speed) + (t1*set_speed_k1) - (s0*speed) - (s1*speed_k1);
	if(voltage > 12) voltage = 12;
	else if (voltage < 0) voltage = 0;
	if(voltage >= 0 ) {
		HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_SET);
		HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);
	}else{
		voltage = -voltage;
		HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
	}
  htim1.Instance->CCR1 = (int)((voltage/12)*1023);
	
}
void multiply_matrix(double x[4][4], uint8_t h, uint8_t c,  double y[4][4], uint8_t p, uint8_t q,  double z[4][4])
{
	uint8_t i, j, k;
	double Temp_mul;
    for ( i = 0 ; i < h ; i++ )
    {
      for ( j = 0 ; j < q ; j++ )
      {
        for ( k = 0 ; k < p ; k++ )
        {
          Temp_mul = Temp_mul + x[i][k]*y[k][j];
        }
        z[i][j] = Temp_mul;
        Temp_mul = 0;
      }
    }
}
void add_matrix(double x[4][4], double y[4][4], uint8_t h, uint8_t c,  double z[4][4])
{
	uint8_t i, j;
    for(i=0;i<h;i++)
       for(j=0;j<c;j++)
            z[i][j]=x[i][j]+y[i][j];
}
void sub_matrix(double x[4][4], double y[4][4], uint8_t h, uint8_t c, double z[4][4])
{
	uint8_t i, j;
    for(i=0;i<h;i++)
       for(j=0;j<c;j++)
            z[i][j]=x[i][j]-y[i][j];
}
void multiply_matrix_number(double x[4][4], uint8_t h, uint8_t c, double y, double z[4][4])
{
	uint8_t i, j;
		   for(i=0;i<h;i++)
       for(j=0;j<c;j++)
            z[i][j]=x[i][j]*y;
}
void divide_matrix_number(double x[4][4], uint8_t h, uint8_t c, double y, double z[4][4])
{
	uint8_t i, j;
	    for(i=0;i<h;i++)
       for(j=0;j<c;j++)
            z[i][j]=x[i][j]/y;
}
void tranpose_matrix(double x[4][4], uint8_t h, uint8_t c, double y[4][4])
{
	uint8_t i, j;
   for(i=0;i<c;i++)
      for(j=0;j<h;j++)
           y[i][j]=0;
  for(i=0;i<c;i++){
      for(j=0;j<h;j++){
           y[i][j]=x[j][i];
      }
  }
}


void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 41;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 1023;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  HAL_TIM_MspPostInit(&htim1);

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_Encoder_InitTypeDef sConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 0xffff;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC1Filter = 0;
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 0;
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 41999;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 19;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/** 
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
  /* DMA1_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_SET);

  /*Configure GPIO pins : PE3 PE1 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
